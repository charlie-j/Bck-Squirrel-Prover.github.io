<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="UTF-8">

  <!-- Begin Jekyll SEO tag v2.3.0 -->
  <title>Squirrel Prover - Tactics</title>

  <!--  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'> -->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <link rel="stylesheet" href="style.css">
<style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>

</head>

<body>
  <a id="anchor-top"></a>
  <section class="page-header">
    <div class="logo-container"> <img src="logo-circular.png" class="logo" > </div>
    <div class="title-buttons">
    <a href="index.html"><h1 class="project-tagline">Squirrel Prover</h2></a>
    <a class="btn" href="https://github.com/squirrel-prover/squirrel-prover/#readme"><i class="fa fa-laptop"></i> Install</a>
    <a class="btn" href="tutorial.html"><i class="fa fa-graduation-cap"></i> Tutorial</a>
    <a class="btn" href="examples.html"><i class="fa fa-cogs"></i> Examples</a>
    <a class="btn" href="https://github.com/squirrel-prover/squirrel-prover/"><i class="fa fa-file-code-o"></i> Source code</a>
    <a class="btn" href="index.html#refs"><i class="fa fa-file-o"></i> Publications</a>
        </div>
  </section>

  <div>
    <section class="main-content">

      <h1></h1>

<!-- do not indent this line, may cause indentation problems in fenced code blocks! -->
<ul>
<li><a href="#logical">Logical</a><ul>
<li><a href="#auto">auto</a></li>
<li><a href="#admit">admit</a></li>
<li><a href="#apply">apply</a></li>
<li><a href="#case">case</a></li>
<li><a href="#exists">exists</a></li>
<li><a href="#have">have</a></li>
<li><a href="#induction">induction</a></li>
<li><a href="#intro">intro</a></li>
<li><a href="#leftright">left/right</a></li>
<li><a href="#rewrite">rewrite</a></li>
<li><a href="#split">split</a></li>
</ul></li>
<li><a href="#structural">Structural</a><ul>
<li><a href="#depends">depends</a></li>
<li><a href="#fa">fa</a></li>
<li><a href="#fadup">fadup</a></li>
<li><a href="#fresh">fresh</a></li>
<li><a href="#project">project</a></li>
</ul></li>
<li><a href="#cryptographic">Cryptographic</a><ul>
<li><a href="#collision">collision</a></li>
<li><a href="#euf">euf</a></li>
<li><a href="#prf">prf</a></li>
</ul></li>
</ul>

<p>The tactics are split in three groups:</p>
<ul>
<li>logical tactics correspond to general logical reasoning (these tactics are similar to the ones you would find in Coq);</li>
<li>structural ones are specific to Squirrel, dealing with equivalences, freshness of names, and systems;</li>
<li>cryptographic tactics are the ones that reflect crypto assumptions.</li>
</ul>
<h1 id="logical">Logical</h1>
<h2 id="auto">auto</h2>
<p>Automatically prove a goal. Performs basic logical reasoning and reasoning on indices, timestamps and message equalities. Does not incorporate any cryptographic reasoning.</p>
<h2 id="admit">admit</h2>
<p>Admit the current goal: it does not count as a valid proof, of course, but is used to leave a subgoal aside to look at the next one, or to let a student treat it as an exercise ;)</p>
<p>If the conclusion is an equivalence, <code>admit N</code> will remove its <code>N</code>-th element.</p>
<h2 id="apply">apply</h2>
<p>The apply tactic allows to use an assumption to prove the conclusion of the current goal. The assumption can start with a series of universal quantifications and implications, ending with a formula that matches the current goal. It will generate new subgoals to justify the implications. It may require the user to provide terms for instantiating the universal quantifications.</p>
<p>Examples: <code>apply H</code>, <code>apply H k</code>, <code>apply le_trans _ t</code>. The last form asks <code>apply</code> to guess the first term but specifies the second one, and it uses a previously proved lemma rather than an hypothesis from the current goal.</p>
<p>When the conclusion is an equivalence, <code>apply</code> use bi-deduction to justify the target equivalence using the one provided by the applied assumption.</p>
<h2 id="case">case</h2>
<p>Case analysis on an hypothesis (<code>case H</code>) a formula (<code>case (i = j)</code>) or a timestamp (<code>case tau</code>).</p>
<h2 id="exists">exists</h2>
<p>Introduce the existentially quantified variables in the conclusion of the judgment, using the arguments as existential witnesses.</p>
<h2 id="have">have</h2>
<p>Syntax: <code>have H : formula</code>.</p>
<p>Prove an intermediate goal, which will then be available as an hypothesis to prove the initial goal.</p>
<h2 id="induction">induction</h2>
<p>Apply the induction scheme to the conclusion.</p>
<h2 id="intro">intro</h2>
<p>Introduce topmost universal quantifications and implications. Names should be provided for universally quantified variables, and identifiers for hypotheses of implications.</p>
<h2 id="leftright">left/right</h2>
<p>When the conclusion is a disjunction, prove its left or right subformula.</p>
<h2 id="rewrite">rewrite</h2>
<p>If <code>H : t1 = t2</code>, the tactic <code>rewrite H</code> will rewrite all occurrences of <code>t1</code> into <code>t2</code> in the conclusion (which can be a local formula, an equivalence or an arbitrary global formula).</p>
<p>The tactic can also be used to rewrite a macro into its definition, by using e.g. <code>rewrite /output</code> for the output macro.</p>
<p>It is possible to rewrite in an hypothesis using <code>rewrite H in H'</code>. It is also possible to rewrite in the reverse direction using <code>rewrite -H</code>.</p>
<h2 id="split">split</h2>
<p>Split a conjunction conclusion, creating one subgoal per conjunct. Also works when the conclusion is an equivalence, seen as a conjunction of two implications.</p>
<h1 id="structural">Structural</h1>
<h2 id="depends">depends</h2>
<p>When action <code>A(i)</code> depends on <code>B(j)</code> in the system under consideration, <code>depends B(j),A(i)</code> introduces the hypothesis <code>B(j)&lt;=A(i)</code> in the goal. It must be done manually, since <code>auto</code> does not take it into account.</p>
<h2 id="fa">fa</h2>
<p>Apply the function application axiom. Concretely, <code>fa N</code> will remove the toplevel function symbol from an equivalence conclusion. It is also possible to invoke the tactic with a pattern to avoid using explicit numbers (which result in fragile proofs): for example, <code>fa &lt;_,_&gt;</code> will use the function application rule on the first item that is a pair.</p>
<h2 id="fadup">fadup</h2>
<p><code>fadup N</code> can remove the <code>N</code>-th item in an equivalence conclusion if this item is of the form <code>exec@tau &amp;&amp; formula</code> and <code>frame@tau</code> is available elsewhere in the equivalence, and <code>formula</code> can be computed from <code>frame@tau</code> assuming <code>exec@tau</code>, in the same way on the left and right projections (hence <code>formula</code> must not contain diff operators).</p>
<h2 id="fresh">fresh</h2>
<p>Attempt to remove a name from an equivalence by showing that it is fresh.</p>
<p>Usage: <code>fresh N</code> where <code>N</code> is the position of the target name.</p>
<h2 id="project">project</h2>
<p>Turn a goal on a multi-system into one goal for each projection of the mutli-system.</p>
<h1 id="cryptographic">Cryptographic</h1>
<h2 id="collision">collision</h2>
<p>Finds all pairs of hashes that are equal according to the current hypothesis, and adds as new hypotheses the equalities of the hashed messages.</p>
<h2 id="euf">euf</h2>
<p>Apply the EUF axiom to the given hypothesis name. The hypothesis must be of the form <code>u = h(v,k)</code> where <code>h</code> is a hash function or <code>checksign(sign(v,pk),sk) = v</code> for a signature scheme.</p>
<p>The equations can be provided in the reverse direction (the tactic will reverse the equation by itself before starting its work) but when both sides of the equality are hashes it might be necessary to orient it first (using <code>have</code> to obtain a new hypothesis with the properly oriented equality) in order to obtain the desired behaviour.</p>
<h2 id="prf">prf</h2>
<p>Apply the PRF axiom. Takes the position of the equivalence item as argument.</p>

      <hr>
      <div class="footer-nav">
        <div class="footer-nav-Body">
          <div class="footer-nav-Row">
            <div class="footer-nav-Left">&nbsp;</div>
            <div class="footer-nav-Mid"><a href="#anchor-top">Top</a></div>
            <div class="footer-nav-Right">&nbsp;</div>
          </div>
        </div>
      </div>
    </section>


  </div>
</body>
